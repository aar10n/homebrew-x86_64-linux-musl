name: Publish Bottles

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Release version tag (e.g., 12.1.0 or 13.4.2-osdev)"
        required: true
        type: string
      run_id:
        description: "Workflow run ID from Build Bottles workflow (leave empty to use latest)"
        required: false
        type: string
      is_default:
        description: "Make this the default formula (x86_64-linux-musl-toolchain)"
        required: false
        type: boolean
        default: false
      arch:
        description: "Target macOS architecture"
        required: false
        default: arm64
        type: choice
        options:
          - arm64
          - intel

permissions:
  contents: write

jobs:
  publish-bottles:
    name: Publish bottles and update formula
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine formula names from version tag
        id: determine
        env:
          VERSION: ${{ inputs.version }}
          ARCH: ${{ inputs.arch }}
        run: |
          # Parse version to extract GCC major version and variant
          # Examples: 12.1.0 -> gcc12, 13.4.2-osdev -> gcc13-osdev

          # Extract GCC major version (first number)
          GCC_MAJOR=$(echo "$VERSION" | grep -oE '^[0-9]+' | head -1)

          # Check for variant suffix
          if [[ "$VERSION" == *"-osdev" ]]; then
            VARIANT_SUFFIX="-osdev"
            VERSIONED_NAME="x86_64-linux-musl-toolchain-osdev@${GCC_MAJOR}"
            DEFAULT_NAME="x86_64-linux-musl-toolchain-osdev"
            BASE_FORMULA="x86_64-linux-musl-osdev"  # For finding old formula
          else
            VARIANT_SUFFIX=""
            VERSIONED_NAME="x86_64-linux-musl-toolchain@${GCC_MAJOR}"
            DEFAULT_NAME="x86_64-linux-musl-toolchain"
            BASE_FORMULA="x86_64-linux-musl"  # For finding old formula
          fi

          # Determine bottle tag/platform label from architecture
          if [[ "$ARCH" == "intel" ]]; then
            BOTTLE_TAG="ventura"
            PLATFORM_LABEL="x86_64_ventura"
          else
            BOTTLE_TAG="arm64_sonoma"
            PLATFORM_LABEL="arm64_sonoma"
          fi

          echo "versioned_formula=${VERSIONED_NAME}" >> $GITHUB_OUTPUT
          echo "default_formula=${DEFAULT_NAME}" >> $GITHUB_OUTPUT
          echo "base_formula=${BASE_FORMULA}" >> $GITHUB_OUTPUT
          echo "gcc_major=${GCC_MAJOR}" >> $GITHUB_OUTPUT
          echo "variant_suffix=${VARIANT_SUFFIX}" >> $GITHUB_OUTPUT
          echo "bottle_tag=${BOTTLE_TAG}" >> $GITHUB_OUTPUT
          echo "platform_label=${PLATFORM_LABEL}" >> $GITHUB_OUTPUT

          echo "Creating versioned formula: ${VERSIONED_NAME}"
          if [[ "${{ inputs.is_default }}" == "true" ]]; then
            echo "Will also create default formula: ${DEFAULT_NAME}"
          fi

      - name: Download bottles from workflow run
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ -n "${{ inputs.run_id }}" ]; then
            RUN_ID="${{ inputs.run_id }}"
          else
            # Get the latest successful run of build-bottles workflow
            RUN_ID=$(gh run list --workflow=build-bottles.yml --status=success --limit=1 --json databaseId --jq '.[0].databaseId')
          fi

          echo "Downloading artifacts from run ID: ${RUN_ID}"

          # Download all artifacts from that run
          gh run download "${RUN_ID}" --pattern 'bottle-*' --pattern 'metadata-*'

      - name: List downloaded artifacts
        run: |
          echo "Downloaded artifacts:"
          find . -name '*.bottle.tar.gz' -o -name '*.json'

      - name: Calculate source tarball SHA256
        id: source_sha
        run: |
          # Download source tarball from the x86_64-linux-musl repo (not the tap repo)
          wget -q "https://github.com/aar10n/x86_64-linux-musl/archive/refs/tags/${{ inputs.version }}.tar.gz"
          SOURCE_SHA=$(shasum -a 256 "${{ inputs.version }}.tar.gz" | awk '{print $1}')
          echo "sha256=${SOURCE_SHA}" >> $GITHUB_OUTPUT
          rm "${{ inputs.version }}.tar.gz"

      - name: Create tag and release if they don't exist
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Fetch tags to ensure we have latest state
          git fetch --tags

          # Check if tag exists
          if ! git tag -l | grep -q "^${{ inputs.version }}$"; then
            echo "Tag ${{ inputs.version }} does not exist, creating it..."
            git tag "${{ inputs.version }}"
            git push origin "${{ inputs.version }}"
          else
            echo "Tag ${{ inputs.version }} already exists"
          fi

          # Check if release exists
          if ! gh release view "${{ inputs.version }}" --repo "${{ github.repository }}" &>/dev/null; then
            echo "Release ${{ inputs.version }} does not exist, creating it..."
            gh release create "${{ inputs.version }}" \
              --repo "${{ github.repository }}" \
              --title "${{ inputs.version }}" \
              --notes "Release ${{ inputs.version }}" \
              --draft
          else
            echo "Release ${{ inputs.version }} already exists"
          fi

      - name: Upload bottles to release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSIONED_FORMULA: ${{ steps.determine.outputs.versioned_formula }}
        run: |
          # Find all bottle files (they're in subdirectories from artifact download)
          # Note: bottle files may have revision numbers like .bottle.1.tar.gz
          for bottle in */*.bottle*.tar.gz; do
            if [ -f "$bottle" ]; then
              # Normalize the filename to what Homebrew expects:
              # - Remove double dashes (formula--version -> formula-version)
              # - Remove revision numbers (.bottle.1.tar.gz -> .bottle.tar.gz)
              normalized=$(basename "$bottle" | sed 's/--/-/g' | sed 's/\.bottle\.[0-9]*\.tar\.gz/.bottle.tar.gz/')

              # Extract the formula name from the bottle (everything before the version number)
              # Example: x86_64-linux-musl-toolchain-gcc12-12.1.0.arm64... -> x86_64-linux-musl-toolchain-gcc12
              original_formula=$(echo "$normalized" | sed -E 's/-[0-9]+\.[0-9]+\.[0-9]+.*//')

              # Upload as versioned formula name
              versioned_name=$(echo "$normalized" | sed "s/^${original_formula}/${VERSIONED_FORMULA}/")
              echo "Uploading ${bottle} as ${versioned_name}..."
              cp "$bottle" "$versioned_name"
              gh release upload "${{ inputs.version }}" "$versioned_name" \
                --repo "${{ github.repository }}" --clobber
              rm "$versioned_name"
            fi
          done

      - name: Install envsubst
        run: |
          sudo apt-get update
          sudo apt-get install -y gettext-base

      - name: Create versioned formula
        env:
          VERSION_TAG: ${{ inputs.version }}
          SOURCE_SHA256: ${{ steps.source_sha.outputs.sha256 }}
          VERSIONED_FORMULA: ${{ steps.determine.outputs.versioned_formula }}
          VARIANT_SUFFIX: ${{ steps.determine.outputs.variant_suffix }}
          BOTTLE_TAG: ${{ steps.determine.outputs.bottle_tag }}
          PLATFORM_LABEL: ${{ steps.determine.outputs.platform_label }}
        run: |
          # Extract bottle SHA256 from metadata
          export BOTTLE_SHA256=$(jq -r '.sha256' */bottle-info-${PLATFORM_LABEL}.json)

          # Convert formula class name
          # x86_64-linux-musl-toolchain@12 -> X8664LinuxMuslToolchainAT12
          # x86_64-linux-musl-toolchain-osdev@12 -> X8664LinuxMuslToolchainOsdevAT12
          # Replace @ with AT, remove underscores, capitalize each word after hyphen, capitalize first letter
          export FORMULA_CLASS=$(echo "$VERSIONED_FORMULA" | sed 's/@/AT/g; s/_//g; s/-\([a-z]\)/\U\1/g; s/^./\U&/')

          # Create versioned formula from template
          VERSIONED_FILE="Formula/${VERSIONED_FORMULA}.rb"
          if [[ -f "$VERSIONED_FILE" ]]; then
            cp "$VERSIONED_FILE" "${VERSIONED_FILE}.existing"
          fi

          envsubst '$FORMULA_CLASS $VERSION_TAG $SOURCE_SHA256 $BOTTLE_SHA256 $BOTTLE_TAG' < formula-versioned.rb > "$VERSIONED_FILE"

          # If we already have bottles for this version (e.g., another arch), merge tags
          if [[ -f "${VERSIONED_FILE}.existing" ]]; then
            python3 - "$VERSIONED_FILE" "${VERSION_TAG}" <<'PY'
          import os
          import re
          import sys
          from pathlib import Path

          new_path = Path(sys.argv[1])
          version_tag = sys.argv[2]
          existing_path = Path(str(new_path) + ".existing")

          if not existing_path.exists():
              sys.exit(0)

          new_text = new_path.read_text()
          old_text = existing_path.read_text()

          # Only merge if we're working on the same version
          same_version = version_tag in old_text
          if not same_version:
              existing_path.unlink()
              sys.exit(0)

          tag_re = re.compile(r'sha256\s+cellar:\s*:any[^,]*,\s*([a-z0-9_]+):\s*"([0-9a-f]{64})"')
          old_tags = {tag: sha for tag, sha in tag_re.findall(old_text)}
          new_tags = {tag: sha for tag, sha in tag_re.findall(new_text)}

          # Keep all existing tags, override with any new ones (this run's arch)
          combined = {**old_tags, **new_tags}

          root_url_line = None
          for line in new_text.splitlines():
              if line.strip().startswith("root_url"):
                  root_url_line = line.strip()
                  break

          if not root_url_line:
              raise SystemExit("root_url not found in bottle block")

          tag_lines = [f'    sha256 cellar: :any, {tag}: "{sha}"' for tag, sha in sorted(combined.items())]
          new_block = "  bottle do\n    " + root_url_line + "\n" + "\n".join(tag_lines) + "\n  end"

          new_text = re.sub(r'(?ms)^  bottle do.*?^  end', new_block, new_text)
          new_path.write_text(new_text)
          existing_path.unlink()
            PY
          fi

          echo "Created versioned formula: $VERSIONED_FILE"
          echo "Formula contents:"
          head -11 "$VERSIONED_FILE"

      - name: Create default formula
        if: inputs.is_default == true
        env:
          VERSION_TAG: ${{ inputs.version }}
          VERSIONED_FORMULA: ${{ steps.determine.outputs.versioned_formula }}
          DEFAULT_FORMULA: ${{ steps.determine.outputs.default_formula }}
          VARIANT_SUFFIX: ${{ steps.determine.outputs.variant_suffix }}
        run: |
          # Convert default formula name to class name
          export FORMULA_CLASS=$(echo "$DEFAULT_FORMULA" | sed 's/@/AT/g; s/_//g; s/-\([a-z]\)/\U\1/g; s/^./\U&/')

          # Set description based on variant
          if [[ "$VARIANT_SUFFIX" == "-osdev" ]]; then
            export FORMULA_DESC="Cross-compilation toolchain for x86_64-linux-musl target (osdev variant)"
          else
            export FORMULA_DESC="Cross-compilation toolchain for x86_64-linux-musl target"
          fi

          # Create default formula from template
          DEFAULT_FILE="Formula/${DEFAULT_FORMULA}.rb"
          envsubst '$FORMULA_CLASS $FORMULA_DESC $VERSION_TAG $VERSIONED_FORMULA' < formula-default.rb > "$DEFAULT_FILE"

          echo "Created default formula: $DEFAULT_FILE"
          echo "Formula contents:"
          head -11 "$DEFAULT_FILE"

      - name: Commit formula updates
        env:
          VERSIONED_FORMULA: ${{ steps.determine.outputs.versioned_formula }}
          DEFAULT_FORMULA: ${{ steps.determine.outputs.default_formula }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add Formula/

          # Only commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to formulas, skipping commit"
          else
            COMMIT_MSG="Add ${VERSIONED_FORMULA} for version ${{ inputs.version }}"
            if [[ "${{ inputs.is_default }}" == "true" ]]; then
              COMMIT_MSG="${COMMIT_MSG} (default)"
            fi
            git commit -m "$COMMIT_MSG"
            git push
          fi

      - name: Publish release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Publish the release (remove draft status)
          gh release edit "${{ inputs.version }}" \
            --repo "${{ github.repository }}" \
            --draft=false

      - name: Create summary
        env:
          VERSIONED_FORMULA: ${{ steps.determine.outputs.versioned_formula }}
          DEFAULT_FORMULA: ${{ steps.determine.outputs.default_formula }}
          PLATFORM_LABEL: ${{ steps.determine.outputs.platform_label }}
        run: |
          {
            echo "# ðŸ¾ Bottle Published"
            echo ""
            echo "**Version:** ${{ inputs.version }}"
            echo "**Formula:** ${VERSIONED_FORMULA}"
            if [[ "${{ inputs.is_default }}" == "true" ]]; then
              echo "**Default:** Yes (${DEFAULT_FORMULA})"
            fi
            echo "**Platform:** ${PLATFORM_LABEL}"
            echo ""
            echo "## Installation"
            echo '```bash'
            echo "brew tap ${{ github.repository }}"
            if [[ "${{ inputs.is_default }}" == "true" ]]; then
              echo "# Install default version:"
              echo "brew install ${DEFAULT_FORMULA}"
              echo ""
              echo "# Or install specific version:"
            fi
            echo "brew install ${VERSIONED_FORMULA}"
            echo '```'
            echo ""
            echo "Formula has been added to the repository."
          } >> $GITHUB_STEP_SUMMARY
